# 分发饼干
# 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
#
# 对每个孩子 i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；
# 并且每块饼干 j，都有一个尺寸 s[j]。如果 s[j]>= g[i]，我们可以将这个饼干 j 分配给孩子 i ，
# 这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
#
import collections
from typing import List


class Solution:
    # 排序，贪心，双指针
    # 题意就是n个孩子，抽出一部分孩子给他们饼干吃，让满足孩子的个数是最大的
    # 用贪心可以理解为，因为要求满足孩子的个数是最大的，
    # 那对于一个孩子来说，如果小尺寸的饼干可以满足，就没必要用大尺寸的饼干，
    # 这样我们就可以把相对大尺寸的饼干留给胃口更大的孩子。
    # 小尺寸的饼干能满足小胃口的孩子满足不了大胃口的孩子，
    # 大尺寸的饼干能满足大胃口的孩子也能满足小胃口的孩子，
    # 因为对于我们来说，满足一个胃口小的孩子和满足一个胃口大的孩子的期望值是一样的，
    # 那就应该小尺寸的饼干用来满足小胃口的孩子，大尺寸的饼干来满足大胃口的孩子。
    # 我们每次从剩下的孩子中，找出胃口最小的孩子，给他能满足他胃口的最小尺寸饼干即可，
    # 这样我们得到的分配方案，是满足孩子的个数最大的。
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        g_n = len(g)
        m_n = len(s)
        ans, pg, ps = 0, 0, 0
        while pg < g_n and ps < m_n:
            # 当前饼干可以满足孩子胃口，喂给孩子，两个指针后移
            if s[ps] >= g[pg]:
                ans += 1
                pg += 1
                ps += 1
            else:
                # 不能满足，选择更大的饼干
                ps += 1

        return ans



a = Solution().findContentChildren(g = [1,2], s = [1,2,3])
print(a)
