# 给定一个整数数组nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
#
#  
#
# 进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
import collections
from typing import List


class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        # return list(set(nums))
        count = collections.Counter(nums)
        return [num for num, occ in count.items() if occ == 1]


    # 之前list里只有一个出现一次的元素的时候用异或，最终得到的就是只出现一次的元素
    # 这个也对每个元素都进行异或，得到的是最终的两个元素的异或和
    # x = x1 ^ x2
    # x显然不会等于0，因为如果x等于0，那么说明x1 = x2，
    # 这样x1和x2就不是只出现一次的数字了
    # 因此，使用位运算x & -x取出x的二进制表示中最低位那个1，设其为第l位
    # 那么x1和x2中的某一个数的二进制表示的第l位为0
    # 另一个数的二进制表示的第l位为1
    # 在这种情况下，x1异或x2的二进制表示的第l位才能为1
    # 这样，就可以把nums中的所有元素分为两类，
    # 其中一类包含所有二进制表示的第l位为0的数
    # 另一类包含所有二进制表示的第l位为1的数
    # 可以发现
    # 对于任意一个在数组中出现两次的元素，该元素的两次出现会被包含在同一类中
    # 对于任意一个在数组中只出现了一次的元素，即x1和x2，他们会被包含在不同类中
    # 因此，如果将每一类的元素全部异或起来，那么其中一类会得到x1，另一类会得到x2
    # 这样我们就找出了这两个只出现一次的元素
    def lsb_singleNumber(self, nums: List[int]) -> List[int]:
        xorsum = 0

        for num in nums:
            xorsum ^= num

        # 为什么要取最低有效位？
        # 因为它是我们对两个数字划分的一种方式，当两个数字的异或某位值为1时，必然存在两个数字在此位上的值不相同
        # 我们取最低有效位，其实是一种划分，其实取任意一位都可以
        # 因为位运算中，取最低位的1比较方便，所以可选的情况下通常选取最低位
        #
        # 举例：5（100）B 2(10)B 3（11）B 3（11）B
        # 答案[5,2],异或是：(110)B
        #
        # 最低有效位对应的值是 2（10）B
        # 对于5 此位是0，对于2 此位是1，就可以把两个数分开
        #
        # 然后我们就想，这个方式有没有不成立的情况呢？
        # 1. 当这两个数相等的时候，不成立，找不到最低有效位。但是他们相等是违背“出现一次”的题目要求的
        #
        # 2. 当剩余数字出现两次在两个分类中各一种的情况下不成立。
        # 但这个是不可能的，对于同一个数字，它的某个数位是不会变化的，所以最终只能归为一类
        #
        # 因为该数字总体上会出现偶数次，所以它的每个数位的1也会出现两次，又只能归为一类
        # 最终必然抵消，不会对结果产生影响
        #
        # 上述例子中， 3 因为和  2（10）B 与 2（10）B 非0，和2划分为一类
        #3(11)B 与 2（10）B 是0，划分为另一类
        # type1=[2,3,3] type2=[5]
        # 第一部分异或得到2，第二部分异或得到5，从而返回结果
        #
        # 综上，可以通过获取最低有效位把两个数分开
        #
        # 防止溢出
        # 因为二进制有正负0，负零用于多表示一位负数，这个负数如果取相反数，会产生溢出，所以不能用 a & (-a) 取最低有效位
        # 负0的特点是第一位是1，其余位是0，所以它的最低有效位就是自己

        lsb = xorsum & (-xorsum)
        type1 = type2 = 0

        for num in nums:
            if num & lsb:
                type1 ^= num
            else:
                type2 ^= num

        return [type1, type2]


