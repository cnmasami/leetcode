# 交替位二进制数

#给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

class Solution:
    # 模拟
    def hasAlternatingBits(self, n: int) -> bool:
        prev = 2
        while n:
            cur = n % 2
            if cur == prev:
                return False
            prev = cur
            n //= 2
        return True

    # 位运算
    # 对输入的二进制表示后移一位后，得到的数字再与n按位异或得到a
    # 当且仅当输入n为交替位二进制数时，a的二进制表示全为1(不包括前导0)
    # 这里进行简单证明：当a的某一位为1时，当且仅当n的对应位和前一位相异
    # 当a的每一位为1时，当且仅当n的所有相邻位相异，即n为交替位二进制数
    # 将a与a+1按位与，当且仅当a的二进制表示全为1时，结果为0.这里进行简单证明
    # 当且仅当a的二进制表示全为1时，a+1可以进位，并将原最高位置为0，按位与的结果为0
    # 否则，不会产生进位，两个最高位都为1，相与结果不为0
    # 当给定值 n 为交替位二进制数时，将 n 右移一位得到的值  m 仍为交替位二进制数，
    # 且与原数  n 错开一位，两者异或能够得到形如0000...1111 的结果
    # x，此时对x 执行加法（进位操作）能够得到形如 0000...10000 的结果，
    # 将该结果与 x 执行按位与后能够得到全 0 结果。

    # 题目要求n的二进制为101010交替，那么n和n右移一位刚好错开，它们异或的结果所有位都会是1。
    # 如果n有任意位有连续的1时，右移异或都会出现某位0。
    # 如何快速判断全部为是1？其实就是判断是否异或结果为2的幂次减一。
    # 判断2的幂次 a的位运算方法为a&(a-1)==0
    def hasAlternatingBits2(self, n: int) -> bool:
        a = n ^ (n >> 1)
        return a & (a+1) == 0

